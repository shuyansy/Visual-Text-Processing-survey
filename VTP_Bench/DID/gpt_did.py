
import time
import openai
import json
from tqdm import tqdm
import os
import cv2
import base64
import random


def get_patch(image, x, y, patch_size=112):
    """
    Extracts a patch of the specified size from the given position in the image.
    """
    return image[y:y + patch_size, x:x + patch_size]

def chat(image_path):
    openai.api_base = "https://api.942ai.com/v1"
    openai.api_key = ""

    # Load and split the image
    image = cv2.imread(image_path)
    width = image.shape[1] // 2
    left_image = image[:, :width]
    right_image = image[:, width:]

    responses = {}

    height, width = left_image.shape[:2]
    patch_size = 224

    for idx in range(1):  # Loop to create 4 corresponding patches
        # Calculate random top-left corner for the patches
        x = random.randint(0, width - patch_size)
        y = random.randint(0, height - patch_size)

        # Get patches from both images at the same position
        left_patch = get_patch(left_image, x, y, patch_size)
        right_patch = get_patch(right_image, x, y, patch_size)

        # Concatenate patches horizontally
        combined = cv2.hconcat([left_patch, right_patch])

        # Save the temporary combined image
        temp_path = "/share/shuyan/VTP/DID/temp/"+image_path.split("/")[-1]
        cv2.imwrite(temp_path, combined)
        with open(temp_path, "rb") as img_file:
            img_base64 = base64.b64encode(img_file.read()).decode("utf-8")

        # Prepare the messages
        messages = [
            {
                "role": "system",
                "content": """
                The image you will receive is composed of two parts: (1) The left section contains the original image. (2) The right section is generated by a model after image dewarping. Please evaluate the modelâ€™s image dewarping capabilities based on the following two criteria:

                (1) Geometric Accuracy (Score: 0-5): Assign a higher score if the dewarped image (the right section) exhibits accurate geometric correction, such as: Straightened lines: Text lines or table lines that should be straight are properly aligned without residual curvature. Shape preservation: The overall shape of the document is correctly restored (e.g., rectangular or square layout). Margin alignment: The edges of the document are neatly aligned and parallel/perpendicular to the frame of the image.
                (2) Content Readability (Score: 0-5): Assign a higher score if the text and visual elements in the dewarped image (the right section) are easy to read and understand, considering: Text clarity: The characters are legible, without distortion, excessive stretching, or compression. Visual continuity: The arrangement of text and other elements (e.g., images, diagrams) appears natural and coherent, with minimal artifacts or noise. Font consistency: The font size and style remain consistent across the document, avoiding irregularities caused by dewarping.

                Output the evaluation strictly in the following JSON format without any additional explanation or comments:
                {'Geometric Accuracy: score_geo, 'Content Readability': score_con, 'total_score': score_geo + score_con}
                """
            },
            {
                "role": "user",
                "content": [{
                    "type": "image_url",
                    "image_url": {"url": f"data:image/jpeg;base64,{img_base64}"}
                }]
            }
        ]

        # Call the OpenAI API
        response = openai.ChatCompletion.create(model="gpt-4o", messages=messages, temperature=0)
        answer = response.choices[0].message['content']
        responses[idx] = answer
        print(f"Response for patch {idx + 1}:", answer)

    return responses

if __name__ == '__main__':
    folder = "select_data/DocTr"
    new_folder = "./DID/evaluation_results/DocTr"
    image_list = os.listdir(folder)

    if not os.path.exists(new_folder):
        os.makedirs(new_folder)

    for i in tqdm(image_list):

        if i.replace(".png", ".json") in os.listdir(new_folder):
            continue

        save_dict = {}
        image_path = os.path.join(folder, i)
        print(f"Processing {image_path}")
        response = chat(image_path)
        print(response)
        save_dict[i] = response

        with open(os.path.join(new_folder, i.replace(".png", ".json")), "w") as f:
            json.dump(save_dict, f)
